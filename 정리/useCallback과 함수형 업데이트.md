## useCallback 제대로 알고 사용하기
- useCallback은 useMemo를 기반으로 만들어져서 두 개는 비슷한 점을 가진 Hooks이다.   
> useCallback은 **특정 함수를 재사용 할 때** 사용하고, useMemo는 **특정 결과값을 재사용 할 때** 사용한다.   
useCallback은 **메모이제이션 된 콜백을 반환**하고, useMemo는 **메모이제이션 된 값을 반환**한다.

- useCallback를 사용할 때 함수 안에서 사용하는 state, props가 있다면, 반드시 deps 배열 안에 포함시켜야한다.   
그리고 컴포넌트에서 props로 함수를 받아왔다면 그 함수도 deps에 포함시켜야한다.   

- **함수를 자식컴포넌트에 props로 넘겨줄 때**는 항상 useCallback을 사용해야한다.   
그렇지 않으면 자식컴포넌트는 계속 새로운 함수를 생성한다고 받아들이기 때문에 렌더링이 계속 실행된다.

- useCallback을 사용하지 않은 함수들은 컴포넌트가 리렌더링 될 때 마다 새로 만들어진다.   
함수가 새로 만들어지는 것이 성능을 떨어뜨리지는 않지만, 컴포넌트 결과물을 재사용하거나 하는 최적화 작업을 할 때 함수를 재사용하는 것이 필요하다.


## useMemo
- 컴포넌트가 업데이트 되고 렌더링 될 때, 업데이트가 필요없는 불필요한 컴포넌트까지 같이 리렌더링 되는 경우가 있다.   
이런 경우 성능이 떨어지게 되는데, 이를 방지하기 위해 사용하는 것이 바로 useMemo 이다.   
useMemo 함수는 **연산된 값을 렌더링 시 재사용할 때** 쓰인다.



## useRef
- useRef Hook은 DOM 선택 용도 외에도, **컴포넌트 안에서 조회 및 수정 가능한 변수를 관리**하는 용도가 있다.   
useRef로 변수를 관리하게 되면, 그 **변수가 업데이트 된다고 해서 컴포넌트가 리렌더링 되지 않는다.** 
> 그래서 화면에 반영되는 얘들은 state로 하고, 아니면 useRef로 하는게 정석

즉, 굳이 리렌더링 할 필요가 없는 변수라면 useRef로 관리해주는 것이 효율적이다.

useRef를 활용한 변수는 아래와 같은 곳에 쓰인다.
- setTimeout, setInterval을 통해 만들어진 id
- scroll 위치
- 배열에 새 항목을 추가할 때 필요한 고유값 key