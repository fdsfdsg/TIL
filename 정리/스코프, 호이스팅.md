## Scope (스코프)
- ES5의 스코프는 함수 레벨 스코프까지 지원해왔다. Javascript에서 var 키워드로 선언된 변수나, 함수 선언식으로 만들어진 함수는 함수 레벨의 스코프를 갖는다. 즉, 함수 내부 전체에서 유효한 식별자가 되어 아래 코드에서 결과는 blue가 된다.
```js
function foo(){
  if (true){
    var color = 'blue';
  }
  console.log(color); //blue
}
```
- 만약 함수 레벨 스코프가 아니라 블록 레벨 스코프였다면, color 변수는 if 절에서 없어지고, console.log에서는 참조 에러가 발생할 것이다.
```js
function foo() {
    if(true) {
        let color = 'blue';
        console.log(color); // blue
    }
    console.log(color); // ReferenceError: color is not defined
}
```
- ES6부터는 블록 레벨의 스코프를 지원해, 위와 같이 let, const 키워드를 통해 블록 레벨 스코프의 사용이 가능해졌다.

## Lexical scoping
- 스코프는 함수를 호출할 때가 아니라, 선언할 때 생긴다. 그래서 렉시컬 스코핑이 아닌, 정적 스코프라고도 불린다.
- 이 말이 조금 이해가 안가긴 하지만, 함수를 선언할 때 함수 내부의 변수들은 현재 자신의 스코프에서 가장 가까운 곳의 변수를 참조한다는 뜻이다.   
   
따라서 아래와 같은 코드에서 모두 name을 출력시킨다고 할 때, 아래와 같은 결과가 나올 수 있는 것이다.   
자세한 내용은 아래의 Execution Context를 참고해보면 훨씬 더 쉽게 이해할 수 있다.   
```js
var name = 'tester';

function log(name) {
  console.log(name);
}
function foo() {
  log(name);
}

function fee() {
  var name = 'fee';
  log(name);
}

foo(); // tester
fee(); // fee
```

## 호이스팅
- 변수를 선언하고 초기화했을 때 선언 부분이 최상단으로 끌어올려지는 현상. Context가 생성되고 해당 scope가 실행되기 전에 이뤄진다. 
- 함수 표현식 `(const a = function(){...})` 이 아닌 함수 선언식`(function a(){...})`일 때는 식이 통째로 끌어올려진다.   
따라서 아래와 같은 코드가 있을 때, sayWow는 호이스팅 되어 정상 실행되지만 sayYeah는 Context에 아직 대입되기 전이기 때문에 에러가 발생한다.
```js
sayWow();
sayYeah();

const sayYeah = function(){
  console.log('yeah');
}

function sayWow(){
  console.log('wow');
}
```

- [let과 const도 호이스팅이 된다.](https://velog.io/@modolee/javascript-let-const-hoisting)
