## 스코프(Scope)

스코프란 유효한 참조 범위를 말한다.
예를 들어, 함수 내부에서 선언된 변수는 함수 내부에서만 참조가 가능하다.

이 경우 변수의 스코프는 함수 내부로 한정 된다.

## 스코프 체인(Scope chain)
내부 함수는 어떤 변수를 찾기 위해 먼저 자기 자신의 스코프에서 찾고, 없으면 한 단계 올라가 외부 스코프에서 찾고, 없으면 다시 올라가 결국 전역 스코프에서 찾는다. 

만약 전역 스코프에도 없다면 변수를 찾지 못하였다는 에러가 발생한다. 이렇게 꼬리를 물고 계속 범위를 넓히면서 찾는 관계를 스코프 체인이라고 부른다.

## 렉시컬 스코핑(Lexical scoping)
- 스코프는 함수를 호출할 때가 아니라, 선언할 때 생긴다. **호출이 아니라 선언할 때!!** 정적 스코프라고도 불린다.
- 함수를 처음 선언한 순간, 함수 내부의 변수는 자기 스코프로부터의 가장 가까운 곳(상위 범위에서)에 있는 변수를 계속 참조하게 된다.   


## 호이스팅
- 변수를 선언하고 초기화했을 때 선언 부분이 최상단으로 끌어올려지는 현상. Context가 생성되고 해당 scope가 실행되기 전에 이뤄진다.

### 함수 선언식

```js
a(); // "123"
function a(){
  console.log("123")
}


// 호이스팅


function a(){
  console.log("123")
}
a(); // "123"
```
함수 선언식이 통째로 최상단으로 올려진다. (함수 선언식은 선언과 동시에 초기화를 함)

### var

```js
console.log(a) //undefined
var a = "123"


// 호이스팅


var a // 선언을 최상단으로 올리고 undefined로 초기화
console.log(a) //undefined
var a = "123"
```
var는 선언부분을 최상단으로 끌어 올리고 undefined로 초기화를 한다.

### let, const
전에는 let과 const는 호이스팅을 하지않는 줄 알았는데, 호이스팅을 한다. TDZ때문에 호이스팅을 안하는 것처럼 보일뿐.
```js
let a = "123" //전역변수로 초기화
if(true){
  console.log(a) // "123"
}
```
let,const는 선언부분을 최상단으로 끌어 올리고 초기화를 하지않는다. 

```js
let a = "123" //전역변수로 초기화
if(true){
  console.log(a) // 참조에러
  let a = "234"
}
```

지역변수 a가 호이스팅되면서 TDZ 구간이 만들어졌기 때문이다.

```js
let a = "123" //전역변수로 초기화
if(true){
  let a  // TDZ시작
  console.log(a) // 참조에러
  // TDZ 끝
  let a = "234"
}
```
### 요약

1. Hoisting 때문에 변수의 선언은 스코프 최상위에 위치 한 것과 동일하게 동작한다.
2. var로 선언 된 변수는 Hoisting 된 다음 undefined의 값으로 초기화 된다.
3. let과 const의 경우 Hoisting 된 다음 초기화가 이루어지지 않는다.
4. let과 const가 Hoisting 되어 선언 된 다음, 초기화 되기까지의 구간을 TDZ라고 부른다.
5. TDZ 구간에서 변수를 참조하려고 하면, 변수 초기화가 되지 않은 상태라서 에러가 뜬다.

#### 참고
- https://velog.io/@mgm-dev/let-const-%EA%B7%B8%EB%A6%AC%EA%B3%A0-TDZ

- https://curryyou.tistory.com/192
